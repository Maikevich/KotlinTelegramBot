1. Чем процесс отличается от потока?
2. Чем Thread отличается от Runnable? Когда нужно использовать Thread, а
когда Runnable?
3. Что такое монитор? Как монитор реализован в java?
4. Что такое синхронизация? Какие способы синхронизации существуют в
java?
5. Как работают методы wait(), notify() и notifyAll()?
6. В каких состояниях может находиться поток?
7. Что такое семафор? Как он реализован в Java?
8. Что обозначает ключевое слово volatile? Почему операции над volatile
переменными не атомарны?
9. Для чего нужны Atomic типы данных? Чем отличаются от volatile?
10. Что такое потоки демоны? Для чего они нужны? Как создать поток демон?
11. Что такое приоритет потока? На что он влияет? Какой приоритет у
потоков по умолчанию?
12. Как работает Thread.join()? Для чего он нужен?
13. Чем отличаются методы yield () “уступать” и sleep()?
14. Как правильно остановить поток? Для чего нужны методы .stop(),
.interrupt(), .interrupted(), .isInterrupted().
15. Чем Runnable отличается от Callable?
16. Что такое FutureTask?
17. Что такое deadlock?
18. Что такое livelock?
19. Что такое race condition?
20. Что такое Фреймворк fork/join? Для чего он нужен?
21. Что означает ключевое слово synchronized? Где и для чего может
использоваться?
22. Что является монитором у статического синхронизированного
класса?
23. Что является монитором у нестатического синхронизированного
класса?
24. util. Concurrent поверхностно.
25. Stream API & ForkJoinPool Как связаны, что это такое.
