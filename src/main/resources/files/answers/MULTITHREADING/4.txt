join, классы джаваутилканкаррент
Синхронизация это механизм, позволяющий обеспечить целостность какого-либо 
ресурса (файл, данные в памяти), когда он используется несколькими процессами или 
потоками в случайном порядке.
Синхронизация это процесс, который позволяет выполнять потоки параллельно.
В Java все объекты имеют одну блокировку, благодаря которой только один поток 
одновременно может получить доступ к критическому коду в объекте. Такая 
синхронизация помогает предотвратить повреждение состояния объекта. Если поток 
получил блокировку, ни один другой поток не может войти в синхронизированный код, 
пока блокировка не будет снята. Когда поток, владеющий блокировкой, выходит из 
синхронизированного кода, блокировка снимается. Теперь другой поток может получить 
блокировку объекта и выполнить синхронизированный код. Если поток пытается 
получить блокировку объекта, когда другой поток владеет блокировкой, поток ждет пока 
блокировка не снимется.
Объявить метод синхронизированным можно только тогда, когда вся логика внутри 
него выполняется одним потоком одновременно.
Недостатком использования synchronized является как раз то, что другие потоки 
вынуждены ждать, пока нужный объект или метод освободится. Это создает так 
называемый "bottle neck" ("узкое место") в программе - и скорость работы может 
пострадать. Поэтому, используйте synchronized с умом по мере необходимости
Способы синхронизации в Java:
• Системная синхронизация с использованием wait()/notify(). 
Когда мы вызываем wait () – это заставляет текущий поток ждать, пока какой-либо 
другой поток вызовет notify () или notifyAll () для того же объекта.
Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта 
метод wait(), предварительно захватив его монитор (вэйт освобождает монитор и 
переводит поток в ожидание, далее поток ждет нотифая). На этом его работа 
приостанавливается. Другой поток может вызвать на этом же самом объекте 
метод notify() (опять же, предварительно захватив монитор объекта), в результате 
чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение. В 
обоих случаях монитор надо захватывать в явном виде, через synchronized-блок, 
потому как методы wait()/notify() не синхронизированы!
notifyAll () - Этот метод просто пробуждает все потоки, которые ожидают на мониторе 
этого объекта.
• Системная синхронизация с использованием join(). Метод join(), вызванный 
у экземпляра класса Thread, позволяет текущему потоку остановиться до того 
момента, как поток, связаный с этим экземпляром, закончит работу. (главный поток 
работает и запускается, ставиться на паузу до окончания дочернего потока)
• Использование классов из пакета java.util.concurrent, который 
предоставляет набор классов для организации межпоточного взаимодействия. 
Примеры таких классов – Atomic, Lock, Semaphore, ForkJoinTask и пр.. Концепция 
данного подхода заключается в использовании атомарных операций и переменных.